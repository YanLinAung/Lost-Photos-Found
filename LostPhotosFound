#!/usr/bin/env python
# -*- coding: utf-8 -*-
# code is under GPLv2
# <caio1982@gmail.com>

"""

LostPhotosFound...

"""

import os
import sys

# for the mime list (all images extensions)
import mimetypes

# to build the mail object and pickle fields
from email import message_from_string
from email.header import decode_header
from email.utils import parsedate

# the working man (should we connect to IMAP as a read-only client btw?)
from imapclient import IMAPClient

# for configuration file
import ConfigParser

class Server:
    """ Server class to fetch and filter data

    Connects to the IMAP server, search according to a criteria,
    fetch all attachments of the mails matching the criteria and
    save them locally with a timestamp.

    """
    def __init__(self, host):
        """ Server class __init__ which expects an IMAP host to connect to

        @param host: gmail's default server is fine: imap.gmail.com
        """

        if not host:
            raise Exception('Missing IMAP host parameter in your config')
        try:
            # isn't it ugly to have so many code inside a try?
            self._server = IMAPClient(host, use_uid=True, ssl=True)
            setattr(self._server, 'debug', False)
        except:
            raise Exception('Could not successfully connect to the IMAP host')

    def login(self, username, password):
        """ Login to the IMAP server and selects the all mail folder
       
        @param username: your gmail account (i.e. obama@gmail.com)
        @param password: we highly recommend you to use 2-factor auth here
        """

        if not username or not password:
            raise Exception('Missing username or password parameters')

        # you may want to hack this to only fetch attachments from a
        # different exclusive label (assuming you have them in english)
        all_mail = '[Gmail]/All Mail'
        
        try:
            self._server.login(username, password)
        except:
            raise Exception('Cannot login, check username/password, are you using 2-factor auth?')

        if not self._server.folder_exists(all_mail):
            for folder in self._server.xlist_folders():
                labels = folder[0]
                if 'AllMail' in labels[-1]:
                    all_mail = folder[2]
    
        self._server.select_folder(all_mail)

    def _filter_messages(self):
        """ Filter mail to only parse ones containing images """

        mimetypes.init()
        mimes = []
        for ext in mimetypes.types_map:
            if 'image' in mimetypes.types_map[ext]:
                mimes.append(ext.replace('.', ''))
        mimelist = ' OR '.join(mimes)
        
        # that's why we only support gmail
        # for other mail services we'd have to translate the custom
        # search to actual IMAP queries, thus no X-GM-RAW cookie for us
        criteria = 'X-GM-RAW "has:attachment filename:(%s)"' % (mimelist)
        try:
            messages = self._server.search([criteria])
        except:
            raise Exception('Search criteria return a failure, it must be a valid gmail search')    

        # stats logging
        print 'LOG: %d messages matched the search criteria %s' % (len(messages), criteria)
        return messages
 
    def lostphotosfound(self):
        """ The actual program is here, say. Call it and it will start saving the images """

        messages = self._filter_messages()
        for msg in messages:
            msgdata = self._server.fetch([msg], ['RFC822'])
            for data in msgdata:
                # SEQ is also available
                mail = message_from_string(msgdata[data]['RFC822'])
                if mail.get_content_maintype() != 'multipart':
                    continue

                # logging
                header = self._header_decoder(mail)
                print '[%s]: %s' % (header[0], header[1])
                
                for part in mail.walk():
                    # if mail is not multipart, i.e. only plain text
                    if part.get_content_maintype() == 'multipart':
                        continue                   
                    # if no explicit attachments unless they're inline
                    if part.get('Content-Disposition') is None:
                        pass
                    # if non-graphic inline data
                    if not 'image/' in part.get_content_type():
                        continue

                    # only then we can save this mail part
                    self._save_part(part, mail)

    def _header_decoder(self, mail):
        """ Internal function to print header logs, subject and from fields

        @param mail: the mail object to get the headers from
        """

        header_from = decode_header(mail['From'])
        header_subject = decode_header(mail['Subject'])

        # string in [0], charset in [1]
        if header_from[0][1] is None:
            header_from = header_from[0][0].decode(
                          'iso-8859-1').encode('utf-8')
        else:
            header_from = header_from[0][0].decode(
                          header_from[0][1]).encode('utf-8')
        
        # string in [0], charset in [1]
        if header_subject[0][1] is None:
            header_subject = header_subject[0][0].decode(
                             'iso-8859-1').encode('utf-8')
        else:
            header_subject = header_subject[0][0].decode(
                             header_subject[0][1]).encode('utf-8')
       
        return (header_from, header_subject)
 
    def _save_part(self, part, mail):
        """ Internal function to decode attachment filenames and save all them

        @param mail: the mail object from message_from_string so it can checks its date
        @param part: the part object after a mail.walk() to get multiple attachments
        """

        if not hasattr(self, "seq"):
            self.seq = 0
        
        # string in [0], charset in [1]
        # besides, we should just call a generic decoding
        # function for any header field we need to read...
        filename = decode_header(part.get_filename())
        if filename[0][1] is None:
            filename = filename[0][0].decode('iso-8859-1').encode('utf-8')
        else:
            filename = filename[0][0].decode(filename[0][1]).encode('utf-8')
            
        # we check if None in filename instead of just if it is None
        # because of the data decode_header returns to us
        if 'None' in filename:
            filename = part.get('Content-Type').split('name=')[-1].replace('"', '')
            if filename is None:
                filename = 'attachment-%06d.data' % (self.seq)
                self.seq += 1
        
        header_date = parsedate(mail['date'])
        header_date = '%s-%s-%s_%s-%s-%s_' % (header_date[0],
                                              header_date[1],
                                              header_date[2],
                                              header_date[3],
                                              header_date[4],
                                              header_date[5])
        filename = header_date + filename
    
        username = config.get('gmail', 'username')
        if not os.path.isdir(username):
            os.mkdir(username)
    
        # logging complement
        print '\t...%s' % (filename)
    
        saved = os.path.join(username, filename)
        if not os.path.isfile(saved):
            with open(saved, 'wb') as imagefile:
                # for some reason get_payload fails sometimes
                # it is suspected to happen when images are not
                # really multipart attachments but inline instead?
                try:
                    payload = part.get_payload(decode=True)
                    imagefile.write(payload)
                except:
                    pass
    
    def close(self):
        """ Gracefully closes and logs out of the IMAP server """

        self._server.close_folder()
        self._server.logout()
    
class Config:
    """ Configuration file manager

    Locate, open and read configuration file options. Create a template
    if no configuration file is found.

    """
    def __init__(self):
        self._dir = os.path.expanduser('~/.LostPhotosFound')
        self._file = os.path.join(self._dir, 'config')

        if not os.path.isdir(self._dir):
            os.mkdir(self._dir, 0700)
            self._create_file()
        elif not os.path.isfile(self._file):
            self._create_file()
        
        self._config = ConfigParser.ConfigParser()
        self._config.read(self._file)

    def get(self, section, option):
        """ Get and return a given config field, i.e. username """
        return self._config.get(section, option)

    def _create_file(self):
        """ Internal function to create a dummy config file if none is found """

        config = ConfigParser.ConfigParser()
        config.add_section('gmail')
        config.set('gmail', 'host', 'imap.gmail.com')
        config.set('gmail', 'username', 'username@gmail.com')
        config.set('gmail', 'password', 'password')

        with open(self._file, 'w') as configfile:
            config.write(configfile)

        print '\nPlease edit your config file %s\n' % (self._file)
        sys.exit()

if __name__ == "__main__":
    config = Config()
    host = config.get('gmail', 'host')
    username = config.get('gmail', 'username')
    password = config.get('gmail', 'password')

    imap = Server(host)
    imap.login(username, password)
    imap.lostphotosfound()
    imap.close()

    print 'All done!'
    sys.exit()
